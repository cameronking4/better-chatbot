import { advancedChatApiRequestBodySchema } from "@/types/advanced-chat";
import { ChatMetadata } from "@/types/chat";
import { advancedChatRepository } from "@/lib/db/repository";
import { chatRepository } from "@/lib/db/repository";
import { advancedChatQueue } from "@/lib/scheduler/advanced-chat-queue";
import { getSession } from "auth/server";
import { validateApiKeyFromHeader } from "@/lib/auth/api-key-auth";
import { generateUUID } from "@/lib/utils";
import { colorize } from "consola/utils";
import globalLogger from "logger";
import { subscribeToJobStream } from "@/lib/scheduler/advanced-chat-stream";

const loggerAdvanced = globalLogger.withDefaults({
  message: colorize("blackBright", `Advanced Chat API: `),
});

// Set maximum duration to 5 minutes for initial request handling
export const maxDuration = 800;

export async function POST(request: Request) {
  try {
    const json = await request.json();

    // Authentication (same as regular chat route)
    let userId: string | undefined;
    let session: Awaited<ReturnType<typeof getSession>> | null = null;

    session = await getSession();
    if (session?.user.id) {
      userId = session.user.id;
      loggerAdvanced.info("Request authenticated via session");
    } else {
      const authHeader = request.headers.get("Authorization");
      const legacyApiKey =
        process.env.NEXT_PUBLIC_API_KEY ?? process.env.CHAT_API_KEY;

      if (authHeader?.startsWith("Bearer ")) {
        const providedKey = authHeader.substring(7);

        const apiKeyAuth = await validateApiKeyFromHeader(request);
        if (apiKeyAuth) {
          userId = apiKeyAuth.userId;
          loggerAdvanced.info(
            `Request authenticated via user API key: ${apiKeyAuth.apiKey.name}`,
          );
        } else if (legacyApiKey && providedKey === legacyApiKey) {
          userId = "dbea8f30-4a6f-4125-87f5-c465b16e2ec9";
          loggerAdvanced.warn(
            "Request authenticated via legacy API key (deprecated)",
          );
        } else {
          loggerAdvanced.warn("Invalid API key provided");
          return new Response("Invalid API key", { status: 401 });
        }
      } else {
        return new Response("Unauthorized", { status: 401 });
      }
    }

    // Validate request body
    const {
      id: threadId,
      message,
      chatModel,
      toolChoice,
      allowedAppDefaultToolkit,
      allowedMcpServers,
      imageTool,
      mentions = [],
      attachments = [],
    } = advancedChatApiRequestBodySchema.parse(json);

    // Load or create thread
    let thread = await chatRepository.selectThreadDetails(threadId);

    if (!thread) {
      loggerAdvanced.info(`Creating chat thread: ${threadId}`);
      const newThread = await chatRepository.insertThread({
        id: threadId,
        title: "",
        userId: userId,
      });
      thread = await chatRepository.selectThreadDetails(newThread.id);
    }

    if (!thread || thread.userId !== userId) {
      return new Response("Forbidden", { status: 403 });
    }

    // Save the initial user message to the thread
    await chatRepository.upsertMessage({
      threadId,
      id: message.id,
      role: message.role,
      parts: message.parts,
      metadata: message.metadata as ChatMetadata | undefined,
    });

    // Generate correlation ID
    const correlationId = generateUUID();

    // Create job in database (job.id will be generated by DB)
    const job = await advancedChatRepository.insertJob({
      threadId,
      userId,
      correlationId,
      metadata: {
        chatModel,
        toolChoice,
        mentions,
        allowedMcpServers,
        allowedAppDefaultToolkit,
        imageTool,
      },
    });

    const jobId = job.id; // Use the ID from the database

    loggerAdvanced.info(
      `Created advanced chat job ${jobId} for thread ${threadId}, userId: ${userId}`,
    );

    // Verify job was created
    const verifyJob = await advancedChatRepository.selectJob(jobId, userId);
    if (!verifyJob) {
      loggerAdvanced.error(`Job ${jobId} not found immediately after creation`);
      return Response.json(
        { message: "Failed to create job" },
        { status: 500 },
      );
    }

    // Add job to queue
    await advancedChatQueue.add(
      `advanced-chat-${jobId}`,
      {
        jobId,
        threadId,
        userId,
        message,
        chatModel,
        toolChoice,
        mentions,
        allowedMcpServers,
        allowedAppDefaultToolkit,
        imageTool,
        attachments,
        correlationId,
      },
      {
        jobId: jobId, // Use jobId as BullMQ job ID
        priority: 1, // High priority
      },
    );

    loggerAdvanced.info(`Queued advanced chat job ${jobId}`);

    // Return streaming response with job status updates
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();

        // Send initial job info
        controller.enqueue(
          encoder.encode(
            `data: ${JSON.stringify({
              type: "job-created",
              jobId,
              correlationId,
              status: "pending",
              threadId,
            })}\n\n`,
          ),
        );

        // Subscribe to Redis pub/sub for real-time message events
        const streamSubscription = subscribeToJobStream(jobId, (event) => {
          try {
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify(event)}\n\n`),
            );
          } catch (error: any) {
            loggerAdvanced.error("Error sending stream event:", error);
          }
        });

        // Poll for job status updates
        const pollInterval = setInterval(async () => {
          try {
            const updatedJob = await advancedChatRepository.selectJob(
              jobId,
              userId,
            );

            if (!updatedJob) {
              clearInterval(pollInterval);
              streamSubscription.unsubscribe();
              controller.enqueue(
                encoder.encode(
                  `data: ${JSON.stringify({
                    type: "error",
                    message: "Job not found",
                  })}\n\n`,
                ),
              );
              controller.close();
              return;
            }

            // Send status update
            controller.enqueue(
              encoder.encode(
                `data: ${JSON.stringify({
                  type: "status-update",
                  jobId,
                  status: updatedJob.status,
                  currentIteration: updatedJob.currentIteration,
                  error: updatedJob.error,
                })}\n\n`,
              ),
            );

            // If job is completed or failed, close stream
            if (
              updatedJob.status === "completed" ||
              updatedJob.status === "failed"
            ) {
              clearInterval(pollInterval);
              streamSubscription.unsubscribe();
              controller.enqueue(
                encoder.encode(
                  `data: ${JSON.stringify({
                    type: "job-complete",
                    jobId,
                    status: updatedJob.status,
                    currentIteration: updatedJob.currentIteration,
                    completedAt: updatedJob.completedAt?.toISOString(),
                    error: updatedJob.error,
                  })}\n\n`,
                ),
              );
              controller.close();
            }
          } catch (error: any) {
            loggerAdvanced.error("Error polling job status:", error);
            clearInterval(pollInterval);
            streamSubscription.unsubscribe();
            controller.enqueue(
              encoder.encode(
                `data: ${JSON.stringify({
                  type: "error",
                  message: error.message,
                })}\n\n`,
              ),
            );
            controller.close();
          }
        }, 1000); // Poll every second

        // Cleanup on abort
        request.signal.addEventListener("abort", () => {
          clearInterval(pollInterval);
          streamSubscription.unsubscribe();
          controller.close();
        });
      },
    });

    return new Response(stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      },
    });
  } catch (error: any) {
    loggerAdvanced.error(error);
    return Response.json({ message: error.message }, { status: 500 });
  }
}

/**
 * GET /api/chat/advanced?jobId=xxx
 * Stream job status updates via SSE
 */
export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const jobId = searchParams.get("jobId");

    if (!jobId) {
      return new Response("jobId parameter required", { status: 400 });
    }

    // Authentication
    let userId: string | undefined;
    const session = await getSession();
    if (session?.user.id) {
      userId = session.user.id;
    } else {
      const apiKeyAuth = await validateApiKeyFromHeader(request);
      if (apiKeyAuth) {
        userId = apiKeyAuth.userId;
      } else {
        return new Response("Unauthorized", { status: 401 });
      }
    }

    // Verify job access
    const job = await advancedChatRepository.selectJob(jobId, userId);
    if (!job) {
      return new Response("Job not found", { status: 404 });
    }

    // Return streaming response with job status updates and message streams
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();

        // Send initial job info
        controller.enqueue(
          encoder.encode(
            `data: ${JSON.stringify({
              type: "job-status",
              jobId,
              status: job.status,
              currentIteration: job.currentIteration,
              error: job.error,
            })}\n\n`,
          ),
        );

        // Subscribe to Redis pub/sub for real-time message events
        const streamSubscription = subscribeToJobStream(jobId, (event) => {
          try {
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify(event)}\n\n`),
            );
          } catch (error: any) {
            loggerAdvanced.error("Error sending stream event:", error);
          }
        });

        // Poll for job status updates
        const pollInterval = setInterval(async () => {
          try {
            const updatedJob = await advancedChatRepository.selectJob(
              jobId,
              userId!,
            );

            if (!updatedJob) {
              clearInterval(pollInterval);
              streamSubscription.unsubscribe();
              controller.enqueue(
                encoder.encode(
                  `data: ${JSON.stringify({
                    type: "error",
                    message: "Job not found",
                  })}\n\n`,
                ),
              );
              controller.close();
              return;
            }

            // Send status update
            controller.enqueue(
              encoder.encode(
                `data: ${JSON.stringify({
                  type: "status-update",
                  jobId,
                  status: updatedJob.status,
                  currentIteration: updatedJob.currentIteration,
                  error: updatedJob.error,
                })}\n\n`,
              ),
            );

            // If job is completed or failed, close stream
            if (
              updatedJob.status === "completed" ||
              updatedJob.status === "failed"
            ) {
              clearInterval(pollInterval);
              streamSubscription.unsubscribe();
              controller.enqueue(
                encoder.encode(
                  `data: ${JSON.stringify({
                    type: "job-complete",
                    jobId,
                    status: updatedJob.status,
                    currentIteration: updatedJob.currentIteration,
                    completedAt: updatedJob.completedAt?.toISOString(),
                    error: updatedJob.error,
                  })}\n\n`,
                ),
              );
              controller.close();
            }
          } catch (error: any) {
            loggerAdvanced.error("Error polling job status:", error);
            clearInterval(pollInterval);
            streamSubscription.unsubscribe();
            controller.enqueue(
              encoder.encode(
                `data: ${JSON.stringify({
                  type: "error",
                  message: error.message,
                })}\n\n`,
              ),
            );
            controller.close();
          }
        }, 1000); // Poll every second

        // Cleanup on abort
        request.signal.addEventListener("abort", () => {
          clearInterval(pollInterval);
          streamSubscription.unsubscribe();
          controller.close();
        });
      },
    });

    return new Response(stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      },
    });
  } catch (error: any) {
    loggerAdvanced.error(error);
    return Response.json({ message: error.message }, { status: 500 });
  }
}
